<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üî¨ Research Paper Fetcher</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: #000;
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .form-container {
            padding: 40px;
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #374151;
            font-size: 1.1em;
        }

        .form-group input[type="text"], .form-group input[type="number"] {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .checkbox-group {
            background: #f9fafb;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #e5e7eb;
        }

        .checkbox-group h3 {
            margin-bottom: 15px;
            color: #374151;
            font-size: 1.2em;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .checkbox-item input[type="checkbox"] {
            margin-right: 10px;
            width: 18px;
            height: 18px;
            accent-color: #4f46e5;
        }

        .checkbox-item label {
            margin-bottom: 0;
            font-weight: 500;
            color: #4b5563;
        }

        .button-group {
            display: flex;
            gap: 15px;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #4f46e5, #7c3aed);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(79, 70, 229, 0.3);
        }

        .btn-secondary {
            background: #10b981;
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #059669;
            transform: translateY(-2px);
        }

        .btn-outline {
            background: transparent;
            border: 2px solid #e5e7eb;
            color: #6b7280;
        }

        .btn-outline:hover {
            background: #f3f4f6;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .progress-container {
            margin: 20px 0;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #4f46e5, #7c3aed);
            border-radius: 4px;
            animation: progress 2s ease-in-out infinite;
        }

        @keyframes progress {
            0% { width: 0%; }
            50% { width: 70%; }
            100% { width: 100%; }
        }

        .status {
            margin: 15px 0;
            padding: 15px;
            border-radius: 8px;
            font-weight: 500;
            display: none;
        }

        .status.info {
            background: #dbeafe;
            color: #1e40af;
            border: 1px solid #3b82f6;
        }

        .status.success {
            background: #d1fae5;
            color: #065f46;
            border: 1px solid #10b981;
        }

        .status.error {
            background: #fee2e2;
            color: #991b1b;
            border: 1px solid #ef4444;
        }

        .results-container {
            margin-top: 30px;
            display: none;
        }

        .results-box {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.9em;
            line-height: 1.5;
        }

        .example-hint {
            background: #f0f9ff;
            border: 1px solid #0ea5e9;
            border-radius: 6px;
            padding: 15px;
            margin: 20px 0;
        }

        .example-hint h4 {
            color: #0c4a6e;
            margin-bottom: 8px;
        }

        .example-hint p {
            color: #0369a1;
            margin-bottom: 5px;
        }

        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .paper-item {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 15px;
            margin: 10px 0;
        }

        .paper-title {
            font-weight: 600;
            color: #1e40af;
            margin-bottom: 8px;
            font-size: 1em;
        }

        .paper-meta {
            color: #64748b;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        @media (max-width: 768px) {
            .form-row {
                grid-template-columns: 1fr;
            }

            .button-group {
                flex-direction: column;
            }

            .btn {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üî¨ Research Paper Fetcher</h1>
            <p>Find and download research papers from wide range of collection! - A Free Tool</p>
        </div>

        <div class="form-container">
            <!-- Removed Vercel notice as requested -->

            <!-- Process Steps Bar -->
            <div id="processSteps" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
                <div class="step" id="step1" style="flex:1; text-align:center; color:#2563eb; font-weight:600;">1. Fetch Papers</div>
                <div style="flex:0.1; text-align:center;">‚Üí</div>
                <div class="step" id="step2" style="flex:1; text-align:center; color:#64748b;">2. Deduplicate</div>
                <div style="flex:0.1; text-align:center;">‚Üí</div>
                <div class="step" id="step3" style="flex:1; text-align:center; color:#64748b;">3. Extract Abstracts</div>
                <div style="flex:0.1; text-align:center;">‚Üí</div>
                <div class="step" id="step4" style="flex:1; text-align:center; color:#64748b;">4. Categorize</div>
                <div style="flex:0.1; text-align:center;">‚Üí</div>
                <div class="step" id="step5" style="flex:1; text-align:center; color:#64748b;">5. Download PDFs</div>
            </div>

            <form id="fetchForm">
                <div class="form-row">
                    <div class="form-group">
                        <label for="keyword">üîç Primary Keyword *</label>
                        <input type="text" id="keyword" name="keyword" value = "serverless" placeholder="e.g., serverless, machine learning, blockchain" required
                            title="Enter the main topic or keyword for your research (e.g., serverless, machine learning, blockchain)">
                        <small style="color:#64748b;">Main topic to search for (e.g., serverless, machine learning, blockchain)</small>
                    </div>
                    <div class="form-group">
                        <label for="additional_keyword">‚ûï Additional Keyword (optional)</label>
                        <input type="text" id="additional_keyword" value = "performance" name="additional_keyword" placeholder="e.g., performance, security, optimization"
                            title="Add a secondary keyword to narrow your search (optional)">
                        <small style="color:#64748b;">Optional: Add a secondary keyword to refine your search (e.g., performance, security)</small>
                    </div>
                </div>
                <div class="form-row" style="display: flex; gap: 20px; align-items: flex-end;">
                    <div class="form-group" style="flex:1; min-width:120px;">
                        <label for="from_year">üìÖ From Year</label>
                        <input type="number" id="from_year" name="from_year" min="1900" max="2030" value="2019" required
                            title="Start year for the publication date range (e.g., 2019)">
                        <small style="color:#64748b;">Start year for papers (e.g., 2019)</small>
                    </div>
                    <div class="form-group" style="flex:1; min-width:120px;">
                        <label for="to_year">üìÖ To Year</label>
                        <input type="number" id="to_year" name="to_year" min="1900" max="2030" value="2025" required
                            title="End year for the publication date range (e.g., 2025)">
                        <small style="color:#64748b;">End year for papers (e.g., 2025)</small>
                    </div>
                    <div class="form-group" style="flex:1; min-width:120px;">
                        <label for="total_results">üìä Number of Results</label>
                        <input type="number" id="total_results" name="total_results" min="1" max="100" value="20" required
                            title="Maximum number of papers to fetch (1-100)">
                        <small style="color:#64748b;">How many papers to fetch (1-100)</small>
                    </div>
                </div>
                <div class="button-group">
                    <button type="submit" class="btn btn-primary" id="fetchBtn">
                        <span id="fetchBtnText">üöÄ Fetch Papers</span>
                        <span id="fetchSpinner" class="spinner" style="display: none;"></span>
                    </button>
                    <button type="button" class="btn btn-secondary" id="fetchMoreBtn" style="display:none;">‚ûï Fetch More Papers</button>
                    <button type="button" class="btn btn-outline" id="deduplicateBtn" style="display:none;" disabled>üîß Deduplicate</button>
                    <button type="button" class="btn btn-outline" id="extractAbstractsBtn" style="display:none;" disabled>üìÑ Extract Abstracts</button>
                    <button type="button" class="btn btn-outline" id="categorizeBtn" style="display:none;" disabled>üìä Categorize & Keywords</button>
                    <button type="button" class="btn btn-outline" id="downloadBtn" disabled>üì• Download CSV</button>
                    <button type="button" class="btn btn-outline" id="downloadPDFBtn" style="display:none;">üìÑ Download PDFs</button>
                    <button type="button" class="btn btn-outline" id="clearBtn">üóëÔ∏è Clear Results</button>
                </div>
                <div class="progress-container" id="progressContainer">
                    <div class="progress-bar">
                        <div class="progress-fill"></div>
                    </div>
                </div>

            </form>
        </div>

        <div class="status" id="statusMessage"></div>
        <div class="results-container" id="resultsContainer">
            <h3>üìÑ Fetch Results</h3>
            <div class="results-box" id="resultsBox"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            let isLoading = false;
            let fetchedPapers = [];
            let allFetchedPapers = [];
            let processStep = 1;

            // Utility: update process steps bar
            function updateProcessSteps(step) {
                for (let i = 1; i <= 5; i++) {
                    const el = document.getElementById(`step${i}`);
                    if (i < step) {
                        el.style.color = '#10b981'; // green for completed
                        el.style.fontWeight = '700';
                    } else if (i === step) {
                        el.style.color = '#2563eb'; // blue for current
                        el.style.fontWeight = '700';
                    } else {
                        el.style.color = '#64748b'; // gray for pending
                        el.style.fontWeight = '600';
                    }
                }
            }

            // Fetch Papers
            document.getElementById('fetchForm').addEventListener('submit', async function(e) {
                e.preventDefault();
                if (isLoading) return;

                // Validate year range
                const fromYear = parseInt(document.getElementById('from_year').value);
                const toYear = parseInt(document.getElementById('to_year').value);

                if (fromYear > toYear) {
                    alert('From Year cannot be greater than To Year');
                    return;
                }

                const formData = new FormData(e.target);
                const data = Object.fromEntries(formData.entries());

                // Set default values for removed checkboxes
                data.title_filter = true; // Default to filtering by title
                data.paper_type_filter = true; // Default to journal and conference papers only

                updateProcessSteps(1);
                // Fetch papers
                await fetchPapers(data, false);
            });

            // Fetch More Papers
            document.getElementById('fetchMoreBtn').addEventListener('click', async function() {
                if (isLoading) return;
                const formData = new FormData(document.getElementById('fetchForm'));
                const data = Object.fromEntries(formData.entries());
                await fetchPapers(data, true);
            });

            // Deduplicate Papers
            document.getElementById('deduplicateBtn').addEventListener('click', async function() {
                if (isLoading || !allFetchedPapers.length) return;

                setLoading(true);
                showProgress();
                showStatus('üîß Deduplicating papers...', 'info');
                updateProcessSteps(2);

                try {
                    const response = await fetch('/api/deduplicate', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ papers: allFetchedPapers })
                    });

                    if (!response.ok) throw new Error('Deduplication failed');

                    const result = await response.json();
                    allFetchedPapers = result.papers;

                    displayPapers(allFetchedPapers);
                    document.getElementById('deduplicateBtn').disabled = true;
                    document.getElementById('extractAbstractsBtn').disabled = false;
                    updateProcessSteps(3);
                    let removed = 0;
                    if ('removed' in result && typeof result.removed === 'number') {
                        removed = result.removed;
                    } else if ('removed_count' in result && typeof result.removed_count === 'number') {
                        removed = result.removed_count;
                    } else if (result.message) {
                        const match = result.message.match(/(\d+)\s+duplicates removed/);
                        if (match) removed = parseInt(match[1], 10);
                    }
                    showStatus(`‚úÖ Deduplication complete! ${removed} duplicates removed. ${allFetchedPapers.length} unique papers remaining.`, 'success');
                } catch (error) {
                    showStatus('‚ùå Error during deduplication: ' + error.message, 'error');
                    console.error('Deduplication error:', error);
                } finally {
                    setLoading(false);
                    hideProgress();
                }
            });

            // Extract Abstracts
            document.getElementById('extractAbstractsBtn').addEventListener('click', async function() {
                if (isLoading || !allFetchedPapers.length) return;

                setLoading(true);
                showProgress();
                showStatus('üìÑ Extracting abstracts from multiple sources...', 'info');
                updateProcessSteps(3);

                try {
                    const response = await fetch('/api/extract-abstracts', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ papers: allFetchedPapers })
                    });

                    if (!response.ok) throw new Error('Abstract extraction failed');

                    const result = await response.json();
                    allFetchedPapers = result.papers;

                    displayPapers(allFetchedPapers);
                    document.getElementById('extractAbstractsBtn').disabled = true;
                    document.getElementById('categorizeBtn').disabled = false;
                    updateProcessSteps(4);
                    showStatus(`‚úÖ Abstract extraction complete! Found abstracts for ${result.found} out of ${allFetchedPapers.length} papers.`, 'success');
                } catch (error) {
                    showStatus('‚ùå Error during abstract extraction: ' + error.message, 'error');
                    console.error('Abstract extraction error:', error);
                } finally {
                    setLoading(false);
                    hideProgress();
                }
            });

            // Categorize & Keywords
            document.getElementById('categorizeBtn').addEventListener('click', async function() {
                if (isLoading || !allFetchedPapers.length) return;

                setLoading(true);
                showProgress();
                showStatus('üìä Categorizing papers and extracting keywords (unsupervised)...', 'info');
                updateProcessSteps(4);

                try {
                    const response = await fetch('/api/unsupervised_categorize', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ papers: allFetchedPapers })
                    });

                    if (!response.ok) throw new Error('Categorization failed');

                    const result = await response.json();
                    // Merge new columns into allFetchedPapers
                    if (result.papers && result.papers.length === allFetchedPapers.length) {
                        for (let i = 0; i < allFetchedPapers.length; i++) {
                            allFetchedPapers[i].original_category = result.papers[i].original_category;
                            allFetchedPapers[i].original_keywords = result.papers[i].original_keywords;
                            allFetchedPapers[i].contributions = result.papers[i].contributions;
                            allFetchedPapers[i].limitations = result.papers[i].limitations;
                        }
                    }
                    displayPapers(allFetchedPapers);
                    document.getElementById('categorizeBtn').disabled = true;
                    updateProcessSteps(5);
                    showStatus(`‚úÖ Categorization complete! Added categories, keywords, contributions, and limitations for ${allFetchedPapers.length} papers.`, 'success');
                } catch (error) {
                    showStatus('‚ùå Error during categorization: ' + error.message, 'error');
                    console.error('Categorization error:', error);
                } finally {
                    setLoading(false);
                    hideProgress();
                }
            });

            // Download PDFs
            document.getElementById('downloadPDFBtn').addEventListener('click', async function() {
                if (allFetchedPapers.length === 0) {
                    showStatus('No papers available for PDF download', 'error');
                    return;
                }
                await downloadPDFsWithProgress(allFetchedPapers);
            });

            async function downloadPDFsWithProgress(papers) {
                if (isLoading) return;

                setLoading(true);
                showProgress();
                clearResults();

                // Show PDF download progress in results box
                document.getElementById('resultsContainer').style.display = 'block';
                document.getElementById('resultsBox').innerHTML = `
                    <div style="margin-bottom: 20px;">
                        <h4>üìÑ PDF DOWNLOAD PROGRESS</h4>
                        <p>Downloading PDFs for <strong>${papers.length}</strong> papers...</p>
                    </div>
                `;

                try {
                    const response = await fetch('/api/download-pdfs-stream', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ papers: papers })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let zipPath = null;
                    let successfulDownloads = 0;
                    let totalPapers = papers.length;

                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');

                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                try {
                                    const data = JSON.parse(line.slice(6));

                                    switch(data.type) {
                                        case 'start':
                                            showStatus(data.message, 'info');
                                            addResultMessage(data.message, 'info');
                                            break;
                                        case 'processing':
                                            addResultMessage(data.message, 'info');
                                            break;
                                        case 'success':
                                            addResultMessage(data.message, 'success');
                                            break;
                                        case 'failed':
                                            addResultMessage(data.message, 'error');
                                            break;
                                        case 'creating_zip':
                                            addResultMessage(data.message, 'info');
                                            showStatus(data.message, 'info');
                                            break;
                                        case 'complete':
                                            successfulDownloads = data.successful;
                                            zipPath = data.zip_path;
                                            showStatus(data.message, 'success');
                                            addResultMessage(data.message, 'success');

                                            // Add download button for the ZIP
                                            const downloadZipBtn = `
                                                <div style="margin-top: 20px; text-align: center;">
                                                    <button onclick="downloadZipFile('papers_pdfs.zip')" class="btn btn-primary">
                                                        üì• Download ZIP (${successfulDownloads} PDFs)
                                                    </button>
                                                </div>
                                            `;
                                            document.getElementById('resultsBox').insertAdjacentHTML('beforeend', downloadZipBtn);
                                            break;
                                        case 'error':
                                            showStatus(data.message, 'error');
                                            addResultMessage(data.message, 'error');
                                            break;
                                    }
                                } catch (e) {
                                    console.error('Error parsing SSE data:', e);
                                }
                            }
                        }
                    }

                    if (successfulDownloads === 0) {
                        showStatus('‚ö†Ô∏è No PDFs were downloaded successfully', 'error');
                        addResultMessage('‚ö†Ô∏è No PDFs were found or downloadable. This could be because:', 'error');
                        addResultMessage('‚Ä¢ Papers may not have direct PDF URLs available', 'info');
                        addResultMessage('‚Ä¢ PDFs may be behind paywalls or require subscriptions', 'info');
                        addResultMessage('‚Ä¢ Some papers may only be available on publisher websites', 'info');
                    }

                } catch (error) {
                    console.error('PDF download error:', error);
                    showStatus('‚ùå Error during PDF download: ' + error.message, 'error');
                    addResultMessage('‚ùå PDF download failed: ' + error.message, 'error');
                } finally {
                    setLoading(false);
                    hideProgress();
                }
            }

            // Function to download the created ZIP file
            function downloadZipFile(zipName) {
                const link = document.createElement('a');
                link.href = `/api/download-zip/${zipName}`;
                link.download = 'research_papers.zip';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                showStatus('üì• ZIP file download started!', 'success');
                addResultMessage('üì• ZIP file download started!', 'success');
            }

            // Download CSV
            document.getElementById('downloadBtn').addEventListener('click', function() {
                if (allFetchedPapers.length > 0) {
                    downloadCSV(allFetchedPapers);
                }
            });

            // Clear Results
            document.getElementById('clearBtn').addEventListener('click', function() {
                clearResults();
                document.getElementById('downloadBtn').disabled = true;
                document.getElementById('downloadPDFBtn').style.display = 'none';
                document.getElementById('fetchMoreBtn').style.display = 'none';
                allFetchedPapers = [];
                fetchedPapers = [];
                updateProcessSteps(1);
                showStatus('Cleared. Ready to fetch papers...', 'info');
            });

            // Main fetch logic
            async function fetchPapers(data, isMore) {
                setLoading(true);
                showProgress();
                showStatus('üîç Starting paper fetch...', 'info');
                if (!isMore) {
                    fetchedPapers = [];
                    allFetchedPapers = [];
                }
                try {
                    // Call backend API instead of CrossRef directly
                    const response = await fetch('/api/fetch', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(data)
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const result = await response.json();

                    if (!result.success) {
                        throw new Error(result.error || 'Failed to fetch papers');
                    }

                    const papers = result.papers || [];

                    if (papers && papers.length > 0) {
                        fetchedPapers = papers;
                        if (isMore) {
                            // Deduplicate by title/DOI
                            const seen = new Set(allFetchedPapers.map(p => p.doi + p.title));
                            for (const p of papers) {
                                if (!seen.has(p.doi + p.title)) {
                                    allFetchedPapers.push(p);
                                    seen.add(p.doi + p.title);
                                }
                            }
                        } else {
                            allFetchedPapers = [...papers];
                        }
                        displayPapers(allFetchedPapers);
                        document.getElementById('downloadBtn').disabled = false;
                        document.getElementById('fetchMoreBtn').style.display = 'inline-block';
                        document.getElementById('downloadPDFBtn').style.display = 'inline-block';

                        // Enable the deduplicate and extract abstracts buttons
                        document.getElementById('deduplicateBtn').style.display = 'inline-block';
                        document.getElementById('deduplicateBtn').disabled = false;
                        document.getElementById('extractAbstractsBtn').style.display = 'inline-block';
                        document.getElementById('extractAbstractsBtn').disabled = true; // Will be enabled after deduplication
                        document.getElementById('categorizeBtn').style.display = 'inline-block';
                        document.getElementById('categorizeBtn').disabled = true; // Will be enabled after abstract extraction

                        updateProcessSteps(2);
                        showStatus(`‚úÖ Completed! Found ${allFetchedPapers.length} papers.`, 'success');
                    } else {
                        showStatus('‚ùå No papers found matching your criteria', 'error');
                    }
                } catch (error) {
                    showStatus('Error occurred during fetch: ' + error.message, 'error');
                    console.error('Fetch error:', error);
                } finally {
                    setLoading(false);
                    hideProgress();
                }
            }

            async function searchCrossrefAPI(keyword, additionalKeyword, fromYear, toYear, totalResults, titleFilter, paperTypeFilter) {
                const papers = [];
                const rowsPerRequest = 20;
                let offset = 0;
                let fetchedCount = 0;
                const maxAttempts = totalResults * 3;
                let processedCount = 0;

                const keywordLower = keyword.toLowerCase().trim();
                const additionalKeywordLower = additionalKeyword.toLowerCase().trim();

                while (fetchedCount < totalResults && processedCount < maxAttempts) {
                    try {
                        const remaining = totalResults - fetchedCount;
                        const currentRows = Math.min(rowsPerRequest, remaining * 2);

                        // Build Crossref API URL
                        let url = 'https://api.crossref.org/works?';

                        if (additionalKeyword.trim()) {
                            url += `query.title=${encodeURIComponent(keyword)}+${encodeURIComponent(additionalKeyword)}`;
                        } else {
                            url += `query.title=${encodeURIComponent(keyword)}`;
                        }

                        url += `&filter=from-pub-date:${fromYear},until-pub-date:${toYear}`;

                        if (paperTypeFilter) {
                            url += ',type:journal-article,type:proceedings-article';
                        }

                        url += `&rows=${currentRows}&offset=${offset}&sort=relevance`;

                        addResultMessage(`üì° Fetching papers ${offset + 1} to ${offset + currentRows}...`, 'info');

                        const response = await fetch(url);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }

                        const data = await response.json();
                        const items = data.message?.items || [];

                        if (items.length === 0) {
                            addResultMessage('‚ö†Ô∏è No more papers found', 'warning');
                            break;
                        }

                        // Process each paper
                        for (const item of items) {
                            processedCount++;

                            if (fetchedCount >= totalResults) break;

                            // Extract title for filtering
                            let title = '';
                            if (item.title && item.title.length > 0) {
                                title = Array.isArray(item.title) ? item.title[0] : item.title;
                            }

                            // Title filtering if enabled
                            if (titleFilter) {
                                const titleLower = title.toLowerCase();
                                const keywordInTitle = titleLower.includes(keywordLower);
                                const additionalInTitle = !additionalKeywordLower || titleLower.includes(additionalKeywordLower);

                                if (!(keywordInTitle && additionalInTitle)) {
                                    continue;
                                }
                            }

                            const paper = extractPaperInfo(item, fetchedCount + 1);
                            papers.push(paper);
                            fetchedCount++;

                            if (fetchedCount % 5 === 0 || fetchedCount === totalResults) {
                                addResultMessage(`   ‚úÖ Found ${fetchedCount}/${totalResults} qualifying papers`, 'success');
                            }
                        }

                        offset += currentRows;

                        // Rate limiting
                        await new Promise(resolve => setTimeout(resolve, 200));

                    } catch (error) {
                        addResultMessage(`‚ùå Error fetching data: ${error.message}`, 'error');
                        break;
                    }
                }

                return papers;
            }

            function extractPaperInfo(item, paperId) {
                // Extract authors
                const authors = [];
                if (item.author) {
                    for (const author of item.author) {
                        if (author.given && author.family) {
                            authors.push(`${author.given} ${author.family}`);
                        } else if (author.family) {
                            authors.push(author.family);
                        }
                    }
                }

                // Extract title
                let title = '';
                if (item.title && item.title.length > 0) {
                    title = Array.isArray(item.title) ? item.title[0] : item.title;
                }

                // Extract abstract
                let abstract = '';
                if (item.abstract) {
                    abstract = item.abstract.replace(/<[^>]+>/g, '').replace(/\s+/g, ' ').trim();
                }

                // Extract journal
                let journal = '';
                if (item['container-title'] && item['container-title'].length > 0) {
                    journal = Array.isArray(item['container-title']) ? item['container-title'][0] : item['container-title'];
                }

                // Extract year
                let year = '';
                if (item['published-print']?.['date-parts']?.[0]?.[0]) {
                    year = item['published-print']['date-parts'][0][0].toString();
                } else if (item['published-online']?.['date-parts']?.[0]?.[0]) {
                    year = item['published-online']['date-parts'][0][0].toString();
                }

                return {
                    paper_id: `paper_${paperId.toString().padStart(3, '0')}`,
                    title: title,
                    abstract: abstract,
                    authors: authors.length > 0 ? authors.join('; ') : 'Not Available',
                    journal: journal,
                    year: year,
                    volume: item.volume || '',
                    issue: item.issue || '',
                    pages: item.page || '',
                    publisher: item.publisher || '',
                    doi: item.DOI || '',
                    url: item.URL || '',
                    type: item.type || ''
                };
            }

            function displayPapers(papers) {
                const resultsBox = document.getElementById('resultsBox');

                // Clear the results box completely and show only the table
                resultsBox.innerHTML = '';

                // Add summary
                const summaryDiv = document.createElement('div');
                summaryDiv.style.marginBottom = '20px';
                summaryDiv.innerHTML = `
                    <h4 style="color: #059669; margin-bottom: 10px;">üìä FETCH SUMMARY</h4>
                    <p style="color: #374151; font-weight: 600;">Total papers: <strong style="color: #059669;">${papers.length}</strong></p>
                `;
                resultsBox.appendChild(summaryDiv);

                // Create table for papers
                const tableContainer = document.createElement('div');
                tableContainer.style.overflowX = 'auto';
                tableContainer.style.marginTop = '20px';
                tableContainer.style.border = '1px solid #e5e7eb';
                tableContainer.style.borderRadius = '8px';
                tableContainer.style.backgroundColor = '#fff';

                const table = document.createElement('table');
                table.style.width = '100%';
                table.style.borderCollapse = 'collapse';
                table.style.fontSize = '0.85em';
                table.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';

                // Table header
                const headerRow = document.createElement('tr');
                headerRow.style.backgroundColor = '#f8fafc';
                headerRow.style.borderBottom = '2px solid #e2e8f0';

                const headers = ['#', 'Title', 'Authors', 'Journal', 'Year', 'DOI'];
                headers.forEach(headerText => {
                    const th = document.createElement('th');
                    th.textContent = headerText;
                    th.style.padding = '12px 8px';
                    th.style.textAlign = 'left';
                    th.style.fontWeight = '600';
                    th.style.color = '#374151';
                    th.style.borderRight = '1px solid #e5e7eb';
                    th.style.position = 'sticky';
                    th.style.top = '0';
                    th.style.backgroundColor = '#f8fafc';
                    th.style.zIndex = '10';

                    // Set column widths
                    if (headerText === '#') th.style.width = '40px';
                    else if (headerText === 'Title') th.style.width = '40%';
                    else if (headerText === 'Authors') th.style.width = '25%';
                    else if (headerText === 'Journal') th.style.width = '20%';
                    else if (headerText === 'Year') th.style.width = '60px';
                    else if (headerText === 'DOI') th.style.width = '15%';

                    headerRow.appendChild(th);
                });
                table.appendChild(headerRow);

                // Table rows
                papers.forEach((paper, index) => {
                    const row = document.createElement('tr');
                    row.style.borderBottom = '1px solid #e5e7eb';
                    row.style.transition = 'background-color 0.2s';

                    // Hover effect
                    row.addEventListener('mouseenter', () => {
                        row.style.backgroundColor = '#f1f5f9';
                    });
                    row.addEventListener('mouseleave', () => {
                        row.style.backgroundColor = 'transparent';
                    });

                    // Row data
                    const rowData = [
                        index + 1,
                        paper.title || 'No title',
                        paper.authors || 'No authors',
                        paper.journal || 'No journal',
                        paper.year || 'No year',
                        paper.doi ? paper.doi.substring(0, 20) + (paper.doi.length > 20 ? '...' : '') : 'No DOI'
                    ];

                    rowData.forEach((cellData, cellIndex) => {
                        const td = document.createElement('td');
                        td.style.padding = '10px 8px';
                        td.style.borderRight = '1px solid #e5e7eb';
                        td.style.verticalAlign = 'top';
                        td.style.wordWrap = 'break-word';

                        // Special styling for different columns
                        if (cellIndex === 0) { // Index
                            td.style.textAlign = 'center';
                            td.style.fontWeight = '600';
                            td.style.color = '#6b7280';
                        } else if (cellIndex === 1) { // Title
                            td.style.fontWeight = '600';
                            td.style.color = '#1e40af';
                            td.style.lineHeight = '1.4';
                        } else if (cellIndex === 4) { // Year
                            td.style.textAlign = 'center';
                            td.style.fontWeight = '600';
                        } else if (cellIndex === 5 && paper.doi) { // DOI
                            td.innerHTML = `<a href="https://doi.org/${paper.doi}" target="_blank" style="color: #059669; text-decoration: none; font-size: 0.8em;">${cellData}</a>`;
                        } else {
                            td.style.color = '#4b5563';
                            td.style.fontSize = '0.9em';
                        }

                        if (cellIndex !== 5 || !paper.doi) {
                            td.textContent = cellData;
                        }

                        row.appendChild(td);
                    });

                    table.appendChild(row);
                });

                tableContainer.appendChild(table);
                resultsBox.appendChild(tableContainer);

                // Add note at bottom
                const noteDiv = document.createElement('div');
                noteDiv.style.marginTop = '15px';
                noteDiv.style.padding = '10px';
                noteDiv.style.backgroundColor = '#f0f9ff';
                noteDiv.style.border = '1px solid #0ea5e9';
                noteDiv.style.borderRadius = '6px';
                noteDiv.style.fontSize = '0.9em';
                noteDiv.style.color = '#0369a1';
                noteDiv.innerHTML = `
                    <strong>üìã Table View:</strong> ${papers.length} papers displayed in table format.
                    Click on DOI links to view papers. Download CSV for complete data including abstracts.
                `;
                resultsBox.appendChild(noteDiv);
            }

            function downloadCSV(papers) {
                const headers = [
                    'paper_id', 'title', 'abstract', 'authors', 'journal', 'year', 'volume', 'issue', 'pages', 'publisher', 'doi', 'url', 'type',
                    'abstract_source', 'abstract_confidence', 'original_category', 'original_keywords', 'contributions', 'limitations'
                ];
                let csvContent = headers.join(',') + '\n';

                papers.forEach(paper => {
                    const row = headers.map(header => {
                        const value = paper[header] || '';
                        // Escape quotes and wrap in quotes if contains comma
                        const escapedValue = value.toString().replace(/"/g, '""');
                        return value.includes(',') || value.includes('"') || value.includes('\n') ? `"${escapedValue}"` : escapedValue;
                    });
                    csvContent += row.join(',') + '\n';
                });

                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);

                const keyword = document.getElementById('keyword').value.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
                const timestamp = new Date().toISOString().slice(0, 19).replace(/[-:]/g, '').replace('T', '_');
                link.setAttribute('download', `papers_${keyword}_${timestamp}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                addResultMessage('üì• CSV file downloaded successfully!', 'success');
            }

            function setLoading(loading) {
                isLoading = loading;
                const fetchBtn = document.getElementById('fetchBtn');
                const fetchBtnText = document.getElementById('fetchBtnText');
                const fetchSpinner = document.getElementById('fetchSpinner');

                fetchBtn.disabled = loading;
                fetchBtnText.style.display = loading ? 'none' : 'inline';
                fetchSpinner.style.display = loading ? 'inline-block' : 'none';
            }

            function showProgress() {
                document.getElementById('progressContainer').style.display = 'block';
            }

            function hideProgress() {
                document.getElementById('progressContainer').style.display = 'none';
            }

            function showStatus(message, type) {
                const statusEl = document.getElementById('statusMessage');
                statusEl.textContent = message;
                statusEl.className = 'status ' + type;
                statusEl.style.display = 'block';
            }

            function clearResults() {
                document.getElementById('resultsBox').innerHTML = '';
                document.getElementById('resultsContainer').style.display = 'block';
                document.getElementById('statusMessage').style.display = 'none';
            }

            function addResultMessage(message, type = 'info') {
                const resultsBox = document.getElementById('resultsBox');
                const timestamp = new Date().toLocaleTimeString();
                const messageEl = document.createElement('div');

                messageEl.style.color = getColorForType(type);
                messageEl.style.marginBottom = '5px';
                messageEl.style.fontFamily = 'Monaco, Menlo, monospace';
                messageEl.style.fontSize = '0.9em';
                messageEl.textContent = `[${timestamp}] ${message}`;

                resultsBox.appendChild(messageEl);
                resultsBox.scrollTop = resultsBox.scrollHeight;
            }

            function getColorForType(type) {
                switch(type) {
                    case 'success': return '#059669';
                    case 'error': return '#dc2626';
                    case 'warning': return '#d97706';
                    default: return '#2563eb';
                }
            }

            // Show initial status
            showStatus('Ready to fetch papers...', 'info');
            updateProcessSteps(1);

            // Live log viewer
            const logElem = document.getElementById('log');
            const evtSource = new EventSource('/api/logs');
            evtSource.onmessage = function(event) {
              logElem.textContent += event.data + '\n';
              logElem.scrollTop = logElem.scrollHeight;
            };
            evtSource.onerror = function() {
              logElem.textContent += '\n[Connection lost to backend log stream]\n';
            };
        });
    </script>
</body>
</html>
